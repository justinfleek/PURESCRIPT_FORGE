{-# LANGUAGE OverloadedStrings #-}
module Runtime where

import qualified Data.Text as T

-- | Generate Haskell runtime library in C++23
generateRuntime :: T.Text
generateRuntime = T.unlines
  [ "// Haskell Runtime Library for C++23"
  , "// Provides lazy evaluation, thunks, and functional programming primitives"
  , ""
  , "#include <memory>"
  , "#include <functional>"
  , "#include <variant>"
  , "#include <optional>"
  , "#include <vector>"
  , "#include <future>"
  , "#include <mutex>"
  , "#include <atomic>"
  , ""
  , "namespace haskell_runtime {"
  , ""
  , "// Forward declarations"
  , "template<typename T> class Thunk;"
  , ""
  , "// Thunk state"
  , "enum class ThunkState {"
  , "  Unevaluated,"
  , "  Evaluating,"
  , "  Evaluated"
  , "};"
  , ""
  , "// Thunk: Lazy evaluation container"
  , "template<typename T>"
  , "class Thunk {"
  , "private:"
  , "  mutable std::atomic<ThunkState> state_{ThunkState::Unevaluated};"
  , "  mutable std::mutex mutex_;"
  , "  std::function<T()> computation_;"
  , "  mutable std::optional<T> value_;"
  , ""
  , "public:"
  , "  explicit Thunk(std::function<T()> computation)"
  , "    : computation_(std::move(computation)) {}"
  , ""
  , "  // Force evaluation (Haskell's seq)"
  , "  T force() const {"
  , "    ThunkState expected = ThunkState::Unevaluated;"
  , "    if (state_.compare_exchange_strong(expected, ThunkState::Evaluating)) {"
  , "      std::lock_guard<std::mutex> lock(mutex_);"
  , "      if (!value_.has_value()) {"
  , "        value_ = computation_();"
  , "      }"
  , "      state_.store(ThunkState::Evaluated);"
  , "      return *value_;"
  , "    } else if (state_.load() == ThunkState::Evaluating) {"
  , "      // Wait for evaluation to complete"
  , "      std::lock_guard<std::mutex> lock(mutex_);"
  , "      while (!value_.has_value()) {"
  , "        std::this_thread::yield();"
  , "      }"
  , "      return *value_;"
  , "    } else {"
  , "      // Already evaluated"
  , "      return *value_;"
  , "    }"
  , "  }"
  , ""
  , "  // Implicit conversion to value (forces evaluation)"
  , "  operator T() const { return force(); }"
  , ""
  , "  // Check if evaluated"
  , "  bool isEvaluated() const {"
  , "    return state_.load() == ThunkState::Evaluated;"
  , "  }"
  , "};"
  , ""
  , "// Lazy function wrapper"
  , "template<typename T>"
  , "auto lazy(std::function<T()> computation) -> Thunk<T> {"
  , "  return Thunk<T>(std::move(computation));"
  , "}"
  , ""
  , "// Strict evaluation"
  , "template<typename T>"
  , "T seq(const Thunk<T>& thunk) {"
  , "  return thunk.force();"
  , "}"
  , ""
  , "// List operations"
  , "template<typename T>"
  , "class List {"
  , "private:"
  , "  std::variant<std::monostate, std::pair<T, std::shared_ptr<List<T>>>> data_;"
  , ""
  , "public:"
  , "  // Nil (empty list)"
  , "  List() : data_(std::monostate{}) {}"
  , ""
  , "  // Cons (head : tail)"
  , "  List(T head, std::shared_ptr<List<T>> tail)"
  , "    : data_(std::make_pair(std::move(head), tail)) {}"
  , ""
  , "  // Check if empty"
  , "  bool isEmpty() const {"
  , "    return std::holds_alternative<std::monostate>(data_);"
  , "  }"
  , ""
  , "  // Get head"
  , "  T head() const {"
  , "    return std::get<std::pair<T, std::shared_ptr<List<T>>>>(data_).first;"
  , "  }"
  , ""
  , "  // Get tail"
  , "  std::shared_ptr<List<T>> tail() const {"
  , "    return std::get<std::pair<T, std::shared_ptr<List<T>>>>(data_).second;"
  , "  }"
  , "};"
  , ""
  , "// List constructors"
  , "template<typename T>"
  , "auto nil() -> List<T> {"
  , "  return List<T>();"
  , "}"
  , ""
  , "template<typename T>"
  , "auto cons(T head, std::shared_ptr<List<T>> tail) -> List<T> {"
  , "  return List<T>(std::move(head), tail);"
  , "}"
  , ""
  , "// Maybe type"
  , "template<typename T>"
  , "using Maybe = std::optional<T>;"
  , ""
  , "template<typename T>"
  , "auto just(T value) -> Maybe<T> {"
  , "  return std::make_optional(std::move(value));"
  , "}"
  , ""
  , "template<typename T>"
  , "auto nothing() -> Maybe<T> {"
  , "  return std::nullopt;"
  , "}"
  , ""
  , "// Either type"
  , "template<typename L, typename R>"
  , "using Either = std::variant<L, R>;"
  , ""
  , "template<typename L, typename R>"
  , "auto left(L value) -> Either<L, R> {"
  , "  return std::variant<L, R>(std::in_place_index<0>, std::move(value));"
  , "}"
  , ""
  , "template<typename L, typename R>"
  , "auto right(R value) -> Either<L, R> {"
  , "  return std::variant<L, R>(std::in_place_index<1>, std::move(value));"
  , "}"
  , ""
  , "// IO monad"
  , "template<typename T>"
  , "class IO {"
  , "private:"
  , "  std::function<T()> action_;"
  , ""
  , "public:"
  , "  explicit IO(std::function<T()> action) : action_(std::move(action)) {}"
  , ""
  , "  T runIO() const { return action_(); }"
  , ""
  , "  template<typename U>"
  , "  IO<U> bind(std::function<IO<U>(T)> f) const {"
  , "    return IO<U>([*this, f]() {"
  , "      T value = this->runIO();"
  , "      return f(value).runIO();"
  , "    });"
  , "  }"
  , "};"
  , ""
  , "// IO constructors"
  , "template<typename T>"
  , "auto returnIO(T value) -> IO<T> {"
  , "  return IO<T>([value]() { return value; });"
  , "}"
  , ""
  , "// Pattern matching helper"
  , "template<typename T, typename... Cases>"
  , "auto match(T&& value, Cases&&... cases) {"
  , "  return std::visit([&](auto&& v) {"
  , "    if constexpr ((std::is_same_v<std::decay_t<decltype(v)>, std::decay_t<Cases>> || ...)) {"
  , "      return std::forward<Cases>(cases)...;"
  , "    }"
  , "  }, std::forward<T>(value));"
  , "}"
  , ""
  , "} // namespace haskell_runtime"
  ]
